# Дифференцирование

Задача дифференцирования может быть решена разными подходами. Несмотря на то, что задача дифферецирования кажется более простой, чем, например, задача интегрирования, в современных инженерных и научных задачах проблемы, связанные с дифференцированием, актуальны не менее, чем проблемы интегрирования.

<img src=".\sources\LETI8\xkcd.png" alt="xkcd" style="zoom:67%;" />

Рассмотрим несколько задач, где возникает необходимость дифференцирования.

### Применение дифференцирования

В задаче гидродинамики для расчета течения жидкости в некоторой области, дискретизированной сеткой, необходимо решать систему уравнений, в матрице которой находятся производные потока жидкости по числовым характеристикам в узлах сетки (например, по давлению жидкости).

<img src=".\sources\LETI6\cc-grid.png" alt="cc-grid" style="zoom: 33%;" /><img src=".\sources\LETI6\fvm-matrix.png" alt="fvm-matrix" style="zoom:50%;" />

Процесс описывает следующее уравнение:

<img src=".\sources\LETI6\cfd.png" alt="cfd" style="zoom:25%;" />

Так как матрица состоит из производных, то дифференцирование уравнений жидкости, которые даны, это первоочередная задача, возникающая в данной области.

Не менее актуально дифференцирование при нахождении корня системы линейных уравнений, например, при применении метода Ньютона или метода наименьших квадратов.

#### Повторение из лекции 11: методы решения СЛАУ

<img src=".\sources\LETI6\fx0.png" alt="fx0" style="zoom:25%;" />

<img src=".\sources\LETI6\fx-taylor-2.png" alt="fx-taylor-2" style="zoom:25%;" />

Здесь $\nabla \mathbf{f(x)}$ - градиент функции:

<img src=".\sources\LETI6\gradf.png" alt="gradf" style="zoom:25%;" />

Поскольку функция $n$-значная и $\mathbf{x}$ – вектор длины $n$, то матрица получается квадратной. Эту матрицу еще называют *якобиан*.

Невязки - разности значений модели и наблюдений в точках, а минимизируется сумма квадратов этих разностей.

<img src=".\sources\LETI6\min-s.png" alt="min-s" style="zoom:25%;" />

<img src=".\sources\LETI6\lsm1a.png" alt="lsm1a" style="zoom:25%;" />

<img src=".\sources\LETI6\lsm-ata.png" alt="lsm-ata" style="zoom:25%;" />

<img src=".\sources\LETI6\lsm-2.png" alt="lsm-2" style="zoom:25%;" />

>  Более подробно см. лекцию 11, пункт «Задачи, в которых появляются СЛАУ»

### Применение дифференцирования (продолжение)

Продолжая тему модели и наблюдательных данных, если модель динамическая, то для составления матрицы $A$, чтобы подогнать состояние динамической системы в произвольные моменты времени к наблюдательным данным, необходимо на этапе численного интегрирования уравнений динамической системы знать частные производные от всех ее правых частей по всем переменным ее состояния.

<img src=".\sources\LETI8\dynamic.png" alt="dynamic" style="zoom: 67%;" />

В задачах, связанных с нейронными сетями, в период обучения даются некоторые входные данные и некоторые выходные, и требуется подстроить параметры нейронов (веса), чтобы входные данные соответствовали выходным. Для всего этого требуется подсчитывать большое количество градиентов, которые отражают ход вычислений между нейронами.

<img src=".\sources\LETI8\neural.png" alt="neural" style="zoom: 67%;" />

Итак, можно сказать, что современные компьютеры большую часть времени занимаются решением СЛАУ, либо дифференцированием для их составления, рассмотрим способы выполнения дифференцирования.

### Виды дифференцирования

Рассмотрим функцию:

<img src=".\sources\LETI8\fx.png" alt="fx" style="zoom:25%;" />

1. Символное дифференцирование дает результат: $f’(x)=0$. Это математический способ, который можно выполнять на бумаге или на компьютере. Несмотря на простой алгоритм, символьным дифференцированием занимаются преимущественно системы компьютерной алгебры, а программы для инженерных и научных расчетов занимаются им в меньшей степени.
2. Численное дифференцирование. Здесь функция $f(x)$ для алгоритмов является черным ящиком.

<img src=".\sources\LETI8\numdiff1.png" alt="numdiff1" style="zoom:25%;" />

Схему можно немного модернизировать и повысить точность результата:

<img src=".\sources\LETI8\numdiff2.png" alt="numdiff2" style="zoom:25%;" />

3. Автоматическое дифференцирование. Данный способ заключается в применении правила взятия полной производной до тех пор, пока его можно применять.

<img src=".\sources\LETI8\autodiff.png" alt="autodiff" style="zoom:25%;" />

В случае применения для заданной функции видов дифференцирования, указанных в п.2 и п.3, в результате не получится 0.

Поговорим о преимуществах и недостатках каждого из видов дифференцирования.

**Символьное дифференцирование**

Достоинство: наиболее точное (потенциально)

Недостатки: 

* не устраняет дублирование вычислений

Пример:

<img src=".\sources\LETI8\wolfram2.png" alt="wolfram2" style="zoom:50%;" />

Не учитывается, что выражения могут повторяться, что можно устранить дублирование введением временных переменных

* сложно формулируется при наличии ветвлений и циклов

Если в формуле есть суммы, ветвления внутри сумм или просто ветвления, то есть они являются частью вычислительной схемы, то символьное дифференцирование становится непрактичным.

Примеры:

<img src=".\sources\LETI8\gravpot.png" alt="gravpot" style="zoom: 45%;" />

**Численное дифференцирование**

Достоинство: просто в реализации

Недостатки:

* наиболее затратно по времени
* может выходить за область определения $f$

Например, $f(x) = \sqrt{-x}$. При нахождении производной в точке 0, посчитать производную по формуле численного дифференцирования невозможно.

![sqrt](.\sources\LETI8\sqrt.png)

Решением может быть проверка области определения и изменение схемы взятия производной или приравнивание ее к 0.

Особенность:

* выдает ненулевой результат в локальном экстремуме $f$

![x2](.\sources\LETI8\x2.png)

Если для данной параболы искать производную в точке 0 по формуле, указанной ниже, то значение будет ненулевым.

<img src=".\sources\LETI8\numdiff1.png" alt="numdiff1" style="zoom:25%;" />

Можно использовать измененную схему:

<img src=".\sources\LETI8\numdiff2.png" alt="numdiff2" style="zoom:25%;" />

Но в большинстве численных методов используется именно первая схема.

Тем не менее, эта особенность не является проблемой в некоторых ситуациях, а может быть даже и преимуществом, потому что происходит косвенный учет членов второго порядка, что можно назвать компенсацией того, что численные методы отбрасывают члены второго порядка, и, оказавшись в точке локального экстремума, не будут «считать», что выход из точки не приведет к изменению функции.

**Автоматическое дифференцирование**

Недостаток: сложно в реализации

Достоинства:

* наиболее быстрое за счет исключения дублирующих вычислений
* легко формируется при наличии циклов, ветвлений, подпроцедур, временных переменных и пр.

#### Пример

Уравнение Кеплера:

<img src=".\sources\LETI8\kepler2.png" alt="kepler2" style="zoom:25%;" />

Программный код, соответствующий этой формуле:

<img src=".\sources\LETI8\kepler3.png" alt="kepler3" style="zoom:50%;" />

Здесь $w_i$ – временные переменные.

Схематично процедуру можно изобразить так:

<img src=".\sources\LETI8\kepler1.png" alt="kepler1" style="zoom:50%;" />

Дифференцирование будем производить по обоим входным параметрам.

<img src=".\sources\LETI8\dm1.png" alt="dm1" style="zoom:50%;" />                    <img src=".\sources\LETI8\dm2.png" alt="dm2" style="zoom:50%;" />

Функция $\mathrm{d}M$ перед присваиванием в каждую из временных переменных делается присваивание двух (их может быть и больше) частных производных. Также видно, что для вычисления новых частных производных можно использовать уже посчитанные ранее, а также сами значения временных переменных.

Данная схема называется прямым автоматическим дифференцированием, оно уместно в ситуациях, когда присутствует достаточно большое количество входных данных и умеренное количество параметров. 

Есть и схема обратного автоматического дифференцирования, которая актуальна для задач, связанных с нейронными сетями, где количество параметров достаточно большое.

Существуют способы комбинировать прямое и обратное автоматическое дифференцирования, так как схемы не гарантируют оптимальной работы алгоритма.

Есть и более глубокие аспекты, связанные с дифференцированием программного кода, например, дифференцирование с рекурсией. С практической точки зрения существует множество пакетов для автоматического дифференцирования.

